var en_us = function(n, ord
) {
  var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,
      n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
  if (ord) return (n10 == 1 && n100 != 11) ? 'one'
      : (n10 == 2 && n100 != 12) ? 'two'
      : (n10 == 3 && n100 != 13) ? 'few'
      : 'other';
  return (n == 1 && v0) ? 'one' : 'other';
};
var number = function (value, name, offset) {
  if (!offset) return value;
  if (isNaN(value)) throw new Error("Can't apply offset:" + offset + ' to argument `' + name + '` with non-numerical value ' + JSON.stringify(value) + '.');
  return value - offset;
};
var plural = function (value, offset, lcfunc, data, isOrdinal) {
  if ({}.hasOwnProperty.call(data, value)) return data[value];
  if (offset) value -= offset;
  var key = lcfunc(value, isOrdinal);
  return key in data ? data[key] : data.other;
};

(window.locales = window.locales || {}).maze_locale = {
  at: function(d) { return "at"; },
  atFlower: function(d) { return "at flower"; },
  atHoneycomb: function(d) { return "at honeycomb"; },
  avoidCowAndRemove: function(d) { return "avoid the cow and remove 1"; },
  collect: function(d) { return "collect"; },
  collectiblePresent: function(d) { return "there is some treasure"; },
  collectorCollectTooltip: function(d) { return "Collect an item"; },
  collectorCollectedEverything: function(d) { return "Congratulations! You collected " + plural(d.count, 0, en_us, { one: "the item", other: "all " + number(d.count, "count") + " items" }) + "!"; },
  collectorCollectedNothing: function(d) { return "Keep coding! You need to collect as many of the items as you can."; },
  collectorCollectedSome: function(d) { return "Great work! You collected " + plural(d.count, 0, en_us, { one: "1 item", other: number(d.count, "count") + " items" }) + "!"; },
  collectorCollectedNotEnough: function(d) { return "Keep coding! You need to collect at least " + plural(d.goal, 0, en_us, { one: "1 item", other: number(d.goal, "goal") + " items" }) + "."; },
  collectorCollectedTooMany: function(d) { return "That space doesn't have enough items for me to collect."; },
  collectorTooManyBlocks: function(d) { return "You can only use " + d.blockLimit + " blocks. Take a look at your code and try again!"; },
  "continue": function(d) { return "Continue"; },
  corn: function(d) { return "corn"; },
  cornTooltip: function(d) { return "Harvest some corn"; },
  didNotCollectAllCrops: function(d) { return "Make sure you don't leave any crops behind!"; },
  didNotCollectEverything: function(d) { return "Make sure you don't leave any nectar or honey behind!"; },
  didNotPlantEverywhere: function(d) { return "Make sure you plant something in every soil patch!"; },
  dig: function(d) { return "remove 1"; },
  digTooltip: function(d) { return "remove 1 unit of dirt"; },
  dirE: function(d) { return "E"; },
  dirN: function(d) { return "N"; },
  dirS: function(d) { return "S"; },
  dirW: function(d) { return "W"; },
  doCode: function(d) { return "do"; },
  elseCode: function(d) { return "else"; },
  emptyCropError: function(d) { return "That crop is all gone."; },
  fill: function(d) { return "fill 1"; },
  fillN: function(d) { return "fill " + d.shovelfuls; },
  fillSquare: function(d) { return "fill square"; },
  fillStack: function(d) { return "fill stack of " + d.shovelfuls + " holes"; },
  fillTooltip: function(d) { return "place 1 unit of dirt"; },
  finalLevel: function(d) { return "Congratulations! You have solved the final puzzle."; },
  flowerEmptyError: function(d) { return "The flower you're on has no more nectar."; },
  get: function(d) { return "get"; },
  getNNectar: function(d) { return "get %1 nectar"; },
  goal: function(d) { return "goal"; },
  has: function(d) { return "has"; },
  haslettuce: function(d) { return "there is lettuce"; },
  hascorn: function(d) { return "there is corn"; },
  haspumpkin: function(d) { return "there are pumpkins"; },
  heightParameter: function(d) { return "height"; },
  holePresent: function(d) { return "there is a hole"; },
  honey: function(d) { return "make honey"; },
  honeyAvailable: function(d) { return "honey"; },
  honeyTooltip: function(d) { return "Make honey from nectar"; },
  honeycombFullError: function(d) { return "This honeycomb does not have room for more honey."; },
  ifCode: function(d) { return "if"; },
  ifFlowerTooltip: function(d) { return "If there is a flower/honeycomb in the specified direction, then do some actions."; },
  ifInRepeatError: function(d) { return "You need an \"if\" block inside a \"repeat\" block. If you're having trouble, try the previous level again to see how it worked."; },
  ifOnlyFlowerTooltip: function(d) { return "If there is a flower in the specified direction, then do some actions."; },
  ifPathAhead: function(d) { return "if path ahead"; },
  ifTooltip: function(d) { return "If there is a path in the specified direction, then do some actions."; },
  ifelseFlowerTooltip: function(d) { return "If there is a flower/honeycomb in the specified direction, then do the first block of actions. Otherwise, do the second block of actions."; },
  ifelseTooltip: function(d) { return "If there is a path in the specified direction, then do the first block of actions. Otherwise, do the second block of actions."; },
  insufficientHoney: function(d) { return "You need to make the right amount of honey."; },
  insufficientNectar: function(d) { return "You need to collect the right amount of nectar."; },
  lettuce: function(d) { return "lettuce"; },
  lettuceTooltip: function(d) { return "Harvest some lettuce"; },
  make: function(d) { return "make"; },
  makeNHoney: function(d) { return "make %1 honey"; },
  moveBackward: function(d) { return "move backward"; },
  moveEastTooltip: function(d) { return "Move me east one space."; },
  moveNForward: function(d) { return "move forward %1 spaces"; },
  moveNForwardTooltip: function(d) { return "Move me forward the specified number of spaces."; },
  moveForward: function(d) { return "move forward"; },
  moveForwardTooltip: function(d) { return "Move me forward one space."; },
  moveNorthTooltip: function(d) { return "Move me north one space."; },
  moveSouthTooltip: function(d) { return "Move me south one space."; },
  moveTooltip: function(d) { return "Move me forward/backward one space"; },
  moveWestTooltip: function(d) { return "Move me west one space."; },
  nectar: function(d) { return "get nectar"; },
  nectarRemaining: function(d) { return "nectar"; },
  nectarTooltip: function(d) { return "Get nectar from a flower"; },
  nextLevel: function(d) { return "Congratulations! You have completed this puzzle."; },
  no: function(d) { return "No"; },
  noPathAhead: function(d) { return "path is blocked"; },
  noPathLeft: function(d) { return "no path to the left"; },
  noPathRight: function(d) { return "no path to the right"; },
  notAtFlowerError: function(d) { return "You can only get nectar from a flower."; },
  notAtHoneycombError: function(d) { return "You can only make honey at a honeycomb."; },
  numBlocksNeeded: function(d) { return "This puzzle can be solved with %1 blocks."; },
  pathAhead: function(d) { return "path ahead"; },
  pathLeft: function(d) { return "if path to the left"; },
  pathRight: function(d) { return "if path to the right"; },
  pick: function(d) { return "pick"; },
  pilePresent: function(d) { return "there is a pile"; },
  plant: function(d) { return "plant"; },
  plantInNonSoilError: function(d) { return "I can only plant something in fresh soil."; },
  plantTooltip: function(d) { return "Plant a sprout"; },
  pumpkin: function(d) { return "pumpkin"; },
  pumpkinTooltip: function(d) { return "Harvest a pumpkin"; },
  putdownTower: function(d) { return "put down tower"; },
  removeAndAvoidTheCow: function(d) { return "remove 1 and avoid the cow"; },
  removeN: function(d) { return "remove " + d.shovelfuls; },
  removePile: function(d) { return "remove pile"; },
  removeSquare: function(d) { return "remove square"; },
  removeStack: function(d) { return "remove stack of " + d.shovelfuls + " piles"; },
  repeatCarefullyError: function(d) { return "To solve this, think carefully about the pattern of two moves and one turn to put in the \"repeat\" block.  It's okay to have an extra turn at the end."; },
  repeatUntil: function(d) { return "repeat until"; },
  repeatUntilBlocked: function(d) { return "while path ahead"; },
  repeatUntilFinish: function(d) { return "repeat until finish"; },
  soil: function(d) { return "soil"; },
  sprout: function(d) { return "sprout"; },
  step: function(d) { return "Step"; },
  totalHoney: function(d) { return "total honey"; },
  totalNectar: function(d) { return "total nectar"; },
  turnLeft: function(d) { return "turn left"; },
  turnRight: function(d) { return "turn right"; },
  turnTooltip: function(d) { return "Turns me left or right by 90 degrees."; },
  uncheckedCloudError: function(d) { return "Make sure to check all clouds to see if they're flowers or honeycombs."; },
  uncheckedPurpleError: function(d) { return "Make sure to check all purple flowers to see if they have nectar"; },
  whileMsg: function(d) { return "while"; },
  whileTooltip: function(d) { return "Repeat the enclosed actions until finish point is reached."; },
  word: function(d) { return "Find the word"; },
  wrongCropError: function(d) { return "I can't harvest that crop from here."; },
  yes: function(d) { return "Yes"; },
  youSpelled: function(d) { return "You spelled"; }
};